<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="你只有十分努力，才能看上去毫不费力">
<meta property="og:type" content="website">
<meta property="og:title" content="_Niceの博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="_Niceの博客">
<meta property="og:description" content="你只有十分努力，才能看上去毫不费力">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="_Nice">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>_Niceの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">_Niceの博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">think twice,code once</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" class="post-title-link" itemprop="url">树链剖分</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-21 21:46:37 / 修改时间：21:47:34" itemprop="dateCreated datePublished" datetime="2020-05-21T21:46:37+08:00">2020-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="树链剖分（洛谷-P3384）"><a href="#树链剖分（洛谷-P3384）" class="headerlink" title="树链剖分（洛谷 P3384）"></a>树链剖分（洛谷 P3384）</h1><h3 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h3><p>LCA、线段树、DFS序</p>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><blockquote>
<p>将树从x到y结点最短路径上所有节点的值都加上z<br>求树从x到y结点最短路径上所有节点的值之和<br>将以x为根节点的子树内所有节点值都加上z<br>求以x为根节点的子树内所有节点值之和</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>重儿子：对于每一个非叶子节点，它的儿子中 儿子数量最多的那一个儿子 为该节点的重儿子<br>轻儿子：对于每一个非叶子节点，它的儿子中 非重儿子 的剩下所有儿子即为轻儿子<br>叶子节点没有重儿子也没有轻儿子（因为它没有儿子。。）<br>重边：连接任意两个重儿子的边叫做重边<br>轻边：剩下的即为轻边<br>重链：相邻重边连起来的 连接一条重儿子 的链叫重链<br>对于叶子节点，若其为轻儿子，则有一条以自己为起点的长度为1的链<br>每一条重链以轻儿子为起点</p>
</blockquote>
<h2 id="dfs1"><a href="#dfs1" class="headerlink" title="dfs1"></a>dfs1</h2><p>这个dfs要处理几件事情：</p>
<blockquote>
<p>标记每个点的深度dep[]<br>标记每个点的父亲fa[]<br>标记每个非叶子节点的子树大小(含它自己)<br>标记每个非叶子节点的重儿子编号son[]</p>
</blockquote>
<pre><code>inline void dfs1(int x,int f,int deep){//x当前节点，f父亲，deep深度 
    dep[x]=deep;//标记每个点的深度 
    fa[x]=f;//标记每个点的父亲 
    siz[x]=1;//标记每个非叶子节点的子树大小 
    int maxson=-1;//记录重儿子的儿子数 
    for(Rint i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(y==f)continue;//若为父亲则continue 
        dfs1(y,x,deep+1);//dfs其儿子 
        siz[x]+=siz[y];//把它的儿子数加到它身上 
        if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 
    }
}</code></pre><h2 id="dfs2"><a href="#dfs2" class="headerlink" title="dfs2"></a>dfs2</h2><p>这个dfs2也要预处理几件事情</p>
<blockquote>
<p>标记每个点的新编号<br>赋值每个点的初始值到新编号上<br>处理每个点所在链的顶端<br>处理每条链</p>
</blockquote>
<p>顺序：先处理重儿子再处理轻儿子，理由后面说</p>
<pre><code>inline void dfs2(int x,int topf){//x当前节点，topf当前链的最顶端的节点 
    id[x]=++cnt;//标记每个点的新编号 
    wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 
    top[x]=topf;//这个点所在链的顶端 
    if(!son[x])return;//如果没有儿子则返回 
    dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 
    for(Rint i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa[x]||y==son[x])continue;
        dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 
    }
}</code></pre><h2 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h2><p><strong>Attention 重要的来了！！！</strong> 前面说到dfs2的顺序是先处理重儿子再处理轻儿子 我们来模拟一下：</p>
<ul>
<li>因为顺序是先重再轻，所以每一条重链的新编号是连续的</li>
<li>因为是dfs，所以每一个子树的新编号也是连续的</li>
</ul>
<p>现在回顾一下我们要处理的问题</p>
<ul>
<li>处理任意两点间路径上的点权和</li>
<li>处理一点及其子树的点权和</li>
<li>修改任意两点间路径上的点权</li>
<li>修改一点及其子树的点权</li>
</ul>
<p>1、当我们要处理任意两点间路径时： 设所在链顶端的深度更深的那个点为x点</p>
<ul>
<li>ans加上x点到x所在链顶端 这一段区间的点权和</li>
<li>把x跳到x所在链顶端的那个点的上面一个点</li>
</ul>
<p>不停执行这两个步骤，直到两个点处于一条链上，这时再加上此时两个点的区间和即可</p>
<p>这时我们注意到，我们所要处理的所有区间均为连续编号(新编号)，于是想到线段树，用线段树处理连续编号区间和每次查询时间复杂度为O(log^2n)</p>
<pre><code>inline int qRange(int x,int y){
    int ans=0;
    while(top[x]!=top[y]){//当两个点不在同一条链上 
        if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点
        res=0;
        query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和
        ans+=res;
        ans%=mod;//按题意取模 
        x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点
    }
    //直到两个点处于一条链上
    if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点
    res=0;
    query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可
    ans+=res;
    return ans%mod;
}</code></pre><p>2、处理一点及其子树的点权和：</p>
<p>想到记录了每个非叶子节点的子树大小(含它自己)，并且每个子树的新编号都是连续的</p>
<p>于是直接线段树区间查询即可</p>
<p>时间复杂度为O(logn)</p>
<pre><code>inline int qSon(int x){
    res=0;
    query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 
    return res;
}</code></pre><p>当然，区间修改就和区间查询一样的啦~~</p>
<pre><code>inline void updRange(int x,int y,int k){
    k%=mod;
    while(top[x]!=top[y]){
        if(dep[top[x]]&lt;dep[top[y]])swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);
        x=fa[top[x]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    update(1,1,n,id[x],id[y],k);
}

inline void updSon(int x,int k){
    update(1,1,n,id[x],id[x]+siz[x]-1,k);
}</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code>#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#define Rint register int
#define mem(a,b) memset(a,(b),sizeof(a))
#define Temp template&lt;typename T&gt;
using namespace std;
typedef long long LL;
Temp inline void read(T &amp;x){
    x=0;T w=1,ch=getchar();
    while(!isdigit(ch)&amp;&amp;ch!=&apos;-&apos;)ch=getchar();
    if(ch==&apos;-&apos;)w=-1,ch=getchar();
    while(isdigit(ch))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^&apos;0&apos;),ch=getchar();
    x=x*w;
}

#define mid ((l+r)&gt;&gt;1)
#define lson rt&lt;&lt;1,l,mid
#define rson rt&lt;&lt;1|1,mid+1,r
#define len (r-l+1)

const int maxn=200000+10;
int n,m,r,mod;
//见题意 
int e,beg[maxn],nex[maxn],to[maxn],w[maxn],wt[maxn];
//链式前向星数组，w[]、wt[]初始点权数组 
int a[maxn&lt;&lt;2],laz[maxn&lt;&lt;2];
//线段树数组、lazy操作 
int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; 
//son[]重儿子编号,id[]新编号,fa[]父亲节点,cnt dfs_clock/dfs序,dep[]深度,siz[]子树大        小,top[]当前链顶端节点 
int res=0;
//查询答案 

inline void add(int x,int y){//链式前向星加边 
    to[++e]=y;
    nex[e]=beg[x];
    beg[x]=e;
}
//-------------------------------------- 以下为线段树 
inline void pushdown(int rt,int lenn){
    laz[rt&lt;&lt;1]+=laz[rt];
    laz[rt&lt;&lt;1|1]+=laz[rt];
    a[rt&lt;&lt;1]+=laz[rt]*(lenn-(lenn&gt;&gt;1));
    a[rt&lt;&lt;1|1]+=laz[rt]*(lenn&gt;&gt;1);
    a[rt&lt;&lt;1]%=mod;
    a[rt&lt;&lt;1|1]%=mod;
    laz[rt]=0;
}

inline void build(int rt,int l,int r){
    if(l==r){
        a[rt]=wt[l];
        if(a[rt]&gt;mod)a[rt]%=mod;
        return;
    }
    build(lson);
    build(rson);
    a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod;
}

inline void query(int rt,int l,int r,int L,int R){
    if(L&lt;=l&amp;&amp;r&lt;=R){res+=a[rt];res%=mod;return;}
    else{
        if(laz[rt])pushdown(rt,len);
        if(L&lt;=mid)query(lson,L,R);
        if(R&gt;mid)query(rson,L,R);
    }
}

inline void update(int rt,int l,int r,int L,int R,int k){
    if(L&lt;=l&amp;&amp;r&lt;=R){
        laz[rt]+=k;
        a[rt]+=k*len;
    }
    else{
        if(laz[rt])pushdown(rt,len);
        if(L&lt;=mid)update(lson,L,R,k);
        if(R&gt;mid)update(rson,L,R,k);
        a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod;
    }
}
//---------------------------------以上为线段树 
inline int qRange(int x,int y){
    int ans=0;
    while(top[x]!=top[y]){//当两个点不在同一条链上 
        if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点
        res=0;
        query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和
        ans+=res;
        ans%=mod;//按题意取模 
        x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点
    }
    //直到两个点处于一条链上
    if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点
    res=0;
    query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可
    ans+=res;
    return ans%mod;
}

inline void updRange(int x,int y,int k){//同上 
    k%=mod;
    while(top[x]!=top[y]){
        if(dep[top[x]]&lt;dep[top[y]])swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);
        x=fa[top[x]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    update(1,1,n,id[x],id[y],k);
}

inline int qSon(int x){
    res=0;
    query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 
    return res;
}

inline void updSon(int x,int k){//同上 
    update(1,1,n,id[x],id[x]+siz[x]-1,k);
}

inline void dfs1(int x,int f,int deep){//x当前节点，f父亲，deep深度 
    dep[x]=deep;//标记每个点的深度 
    fa[x]=f;//标记每个点的父亲 
    siz[x]=1;//标记每个非叶子节点的子树大小 
    int maxson=-1;//记录重儿子的儿子数 
    for(Rint i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(y==f)continue;//若为父亲则continue 
        dfs1(y,x,deep+1);//dfs其儿子 
        siz[x]+=siz[y];//把它的儿子数加到它身上 
        if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 
    }
}

inline void dfs2(int x,int topf){//x当前节点，topf当前链的最顶端的节点 
    id[x]=++cnt;//标记每个点的新编号 
    wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 
    top[x]=topf;//这个点所在链的顶端 
    if(!son[x])return;//如果没有儿子则返回 
    dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 
    for(Rint i=beg[x];i;i=nex[i]){
        int y=to[i];
        if(y==fa[x]||y==son[x])continue;
        dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 
    }
}

int main(){
    read(n);read(m);read(r);read(mod);
    for(Rint i=1;i&lt;=n;i++)read(w[i]);
    for(Rint i=1;i&lt;n;i++){
        int a,b;
        read(a);read(b);
        add(a,b);add(b,a);
    }
    dfs1(r,0,1);
    dfs2(r,r);
    build(1,1,n);
    while(m--){
        int k,x,y,z;
        read(k);
        if(k==1){
            read(x);read(y);read(z);
            updRange(x,y,z);
        }
        else if(k==2){
            read(x);read(y);
            printf(&quot;%d\n&quot;,qRange(x,y));
        }
        else if(k==3){
            read(x);read(y);
            updSon(x,y);
        }
        else{
            read(x);
            printf(&quot;%d\n&quot;,qSon(x));
        }
    }
}</code></pre><p>代码很长，但思路简单，写的时候千万仔细，变量命名最好贴切，否则写挂的话debug会花费不少时间，（永无乡Splay写挂了查了两天愣是一直90分，最后还是去学了线段树合并水过去了-_-）</p>
<p><strong>转自<a href="https://www.cnblogs.com/chinhhh/p/7965433.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinhhh/p/7965433.html</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/" class="post-title-link" itemprop="url">乘法逆元</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-15 20:40:23 / 修改时间：20:41:00" itemprop="dateCreated datePublished" datetime="2020-05-15T20:40:23+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在数论中， 如果ab ≡ 1（mod p）, 即 p | (ab-1)（|是整除的意思）我们就说 a 和 b 在模 p 意义下互为乘法逆元, 记做 a = inv(b).<br>逆元有什么用呢？我们常常遇到一些题目要求结果对一个大质数 p 取模，这是因为答案很大，出题人为了不麻烦大家写高精，就采取这样的方法。加减法和乘法对取模运算都是封闭的，所以你可以处处取模来避免溢出。但遇到除法时，就麻烦了。</p>
<blockquote>
<p>（12 / 3） % 4 ≠ (12%4 / 3%4) % 4</p>
</blockquote>
<p>为了解决模意义下的除法问题，我们引入了逆元。 inv(a) 其实可以看做模 p 意义下的 $$a^{-1}$$ ，那么在模 p 意义下， $$\frac{a}{b}$$ 就可以变形为 a*inv(b) % p 。<br>实际上在模 10 意义下 inv(3)=7 ，所以上面的式子可以这样计算：</p>
<blockquote>
<p>(12 / 3) % 4 = (12<em>inv(3)) % 4 = (12</em>7) % 4 = 4</p>
</blockquote>
<p>显然结果是正确的</p>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="1-扩展欧几里得求逆"><a href="#1-扩展欧几里得求逆" class="headerlink" title="1.扩展欧几里得求逆"></a>1.扩展欧几里得求逆</h3><p>如果你还不会扩欧，那可以看下<a href="https://k-nice.github.io/2020/04/28/%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%85%83%E4%B8%80%E6%AC%A1%E6%96%B9%E7%A8%8B/" target="_blank" rel="noopener">这篇博客</a>。 因为ax ≡ 1（mod p）等价于ax+by = 1, 那么就可以通过扩欧来求解x，复杂度O(logp)由此我们还可以得出逆元存在的冲要条件是gcd(a,p) = 1。</p>
<h3 id="2-费马小定理求逆"><a href="#2-费马小定理求逆" class="headerlink" title="2.费马小定理求逆"></a>2.费马小定理求逆</h3><p>注意，这种求逆元的方法仅使用在 p 为质数的时候</p>
<blockquote>
<p>费马小定理：若 p 为质数，且整数 a 满足 gcd(a,p) = 1 ，则有 $$a^{p-1}$$ ≡ 1 (mod p), 又因为a<em>b ≡ c (mod p) 等价于 ((a%p)</em>b) ≡ c (mod p),（这个可以自己写下式子模拟下就清楚了），所以a在模p意义下的逆元即为$$a^{p-2}$$%p，用快速幂求解即可。<br>一道例题<a href="https://www.luogu.com.cn/problem/P2613" target="_blank" rel="noopener">有理数取余</a>, 这道题可以加深你对分数取余的 理解，请仔细体会其与除法取余的区别。</p>
</blockquote>
<h3 id="3-线性求逆"><a href="#3-线性求逆" class="headerlink" title="3.线性求逆"></a>3.线性求逆</h3><p>基于拓展欧几里得算法，我们虽然可以在 O(nlogp) 时间内，求出 [1,n] (1 &lt;= n &lt; p) 中所有整数在模质数 [公式] 下的乘法逆元，但在面对更大的数据范围时，我们就需要更快的方法。<br>注意，这种求逆元的方法仅使用在 p 为质数的时候。因为难免出现[1,n]内存在数x使gcd(x,p) ≠ 1, 那么它自然就不存在模p意义下的逆元，而后面的逆元都是根据前面求出的逆元得来的，这将导致后面一连串的逆元都是错的。<br>我们设p = ki + r,(r &lt; i, 1 &lt; i &lt; p), 将其转换为同余方程得到：</p>
<blockquote>
<p>ki + r ≡ 0 (mod p)</p>
</blockquote>
<p>两边同乘以$$i^{-1}$$和$$r^{-1}$$,得：</p>
<blockquote>
<p>k$$r^{-1}$$ + $$i^{-1}$$ = 0 (mod p)</p>
</blockquote>
<p>移项得:</p>
<blockquote>
<p>$$i^{-1}$$ = -k$$r^{-1}$$ (mod p)</p>
</blockquote>
<p>将 k = $$\lfloor \frac{p}{i} \rfloor$$, r = p%i代入得：</p>
<blockquote>
<p>$$i^{-1}$$ = -$$\lfloor \frac{p}{i} \rfloor$$*$$(p%i)^{-1}$$ (mod p)</p>
</blockquote>
<p>注意-$$\lfloor \frac{p}{i} \rfloor$$为负数，在模p意义下，其等价于p-$$\lfloor \frac{p}{i} \rfloor$$, 故有递推式：</p>
<blockquote>
<p>$$i^{-1}$$ = (p-$\lfloor \frac{p}{i} \rfloor$)*$(p%i)^{-1}$ (mod p)</p>
</blockquote>
<p>复杂度O(n)，<a href="https://www.luogu.com.cn/problem/P3811" target="_blank" rel="noopener">模板题</a></p>
<h3 id="4-离线逆元"><a href="#4-离线逆元" class="headerlink" title="4.离线逆元"></a>4.离线逆元</h3><p>其用于求解给定n个数在模p下的乘法逆元，这时递推式不再适用，时间空间都会爆炸。因为该算法并不常用，因此在此不再赘述，有兴趣的可以参考<a href="https://www.luogu.com.cn/problem/P5431" target="_blank" rel="noopener">这道题</a>，题解讲的十分清楚。</p>
<p>注：本篇内容借鉴于<a href="https://www.luogu.com.cn/blog/1239004072Angel/post-shuo-xue-sheng-fa-ni-yuan" target="_blank" rel="noopener">洛谷日报</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/%E5%85%B3%E4%BA%8EC-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/04/%E5%85%B3%E4%BA%8EC-%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA/" class="post-title-link" itemprop="url">关于C++未定义行为</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-04 21:40:01" itemprop="dateCreated datePublished" datetime="2020-05-04T21:40:01+08:00">2020-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-06 22:31:55" itemprop="dateModified" datetime="2020-05-06T22:31:55+08:00">2020-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关于C-未定义行为-undefined-behavior"><a href="#关于C-未定义行为-undefined-behavior" class="headerlink" title="关于C++未定义行为(undefined behavior)"></a>关于C++未定义行为(undefined behavior)</h1><p>代码出现bug是再正常不过的事情，然而找bug也是一件令人十分头疼的苦差事。<del>曾一段时间日常debug三四小时的蒟蒻飘过QWQ</del>如果是符合逻辑的错误那还好说，但如果出现了一些执行情况不确定的错误，而你又天真地认为它们“应该”会执行出那样的效果，那这毫无疑问会让你之后的debug旅途变得<del>丰富多彩</del>。所以学习UB是必要的，<del>由于我又菜又懒</del>，这里推荐<a href="https://studyingfather.blog.luogu.org/undefined-behavior" target="_blank" rel="noopener">一篇博客</a>，讲的十分清晰，希望能帮到你。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%85%83%E4%B8%80%E6%AC%A1%E6%96%B9%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/28/%E6%B1%82%E8%A7%A3%E4%BA%8C%E5%85%83%E4%B8%80%E6%AC%A1%E6%96%B9%E7%A8%8B/" class="post-title-link" itemprop="url">求解二元一次方程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-28 15:47:33" itemprop="dateCreated datePublished" datetime="2020-04-28T15:47:33+08:00">2020-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-04 22:10:19" itemprop="dateModified" datetime="2020-05-04T22:10:19+08:00">2020-05-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二元一次不定方程-exged"><a href="#二元一次不定方程-exged" class="headerlink" title="二元一次不定方程(exged)"></a>二元一次不定方程(exged)</h1><h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><blockquote>
<p>题目概要<br>拓展欧几里得算法(exgcd)<br>求二元一次方程/线性同余方程特解<br>求二元一次方程/线性同余方程通解<br>解决问题</p>
</blockquote>
<h2 id="题目概要"><a href="#题目概要" class="headerlink" title="题目概要"></a>题目概要</h2><p>给定二元一次不定方程ax+by=c<br>若该方程无整数解，输出 -1<br>若该方程有整数解，且有正整数解，则输出其正整数解的数量，所有正整数解中 x 的最小值，所有正整数解中 y 的最小值，所有正整数解中 x 的最大值，以及所有正整数解中 y 的最大值<br>若方程有整数解，但没有正整数解，你需要输出所有整数解中 x 的最小正整数值， y 的最小正整数值</p>
<p>正整数解即为 x,y 均为正整数的解<br>整数解即为 x,y 均为整数的解<br>x 的最小正整数值即所有 x 为正整数的整数解中 x 的最小值，y 同理</p>
<p>数据范围：1&lt;=a,b,c&lt;=1e9  ， 输入含有多组数据，数据组数不超过2*10^5</p>
<p>样例输入：<br>2<br>2 11 100<br>3 18 6</p>
<p>样例输出:<br>4 6 2 39 8<br>2 1</p>
<h2 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h2><p>扩展欧几里得算法：用于求解形如ax+by=gcd(a,b)的不定方程特解。<br><strong><em>求解方法&amp;证明：</em></strong> 当b=0时，可以看出gcd(a,b)=a，而x=1,y=0是方程的一组特解<br>当b!=0时，根据欧几里得算法递归求解exgcd(b,a%b,x,y)，设a’=b,b’=a%b,可以求得a’x’+b’y’=gcd(a,b)的一组特解，即x’,y’。<br>而ax+by=gcd(a,b)=a’x’+b’y’,将a’=b,b’=a%b代入，得x=y’,y=x-a/b*y’。</p>
<p><strong>Code</strong></p>
<pre><code>int exgcd(int a,int b,int &amp;x,int &amp;y)
    {
        if(!b)
        {
            x=1;
            y=0;
            return a;
        }
        int k=exgcd(b,a%b,x,y);
        int p=x;
        x=y;
        y=p-(a/b)*y;
        return k;
    }</code></pre><h2 id="求二元一次方程组的特解"><a href="#求二元一次方程组的特解" class="headerlink" title="求二元一次方程组的特解"></a>求二元一次方程组的特解</h2><p>二元一次方程： 对于形如ax+by=c的二元一次方程，裴蜀定理指出，当且仅当gcd(a,b)|c(|为整除)时，存在整数解。由裴蜀定理我们可以得到一个推论：a,b互质的充要条件是存在整数x,y使ax+by=1.<br>设g=gcd(a,b),a’=a/g,b’=b/g,c’=c/g,则ax+by=c⇔a’x+b’y=c’，<br>此时gcd(a’,b’)=1,可以利用exgcd求出a’x’+b’y’=1的一组特解，继而得出x=c’<em>y’, y=c’</em>x’,从而得到ax+by=c的一组特解</p>
<p>线性同余方程： 对于形如ax\equiv≡c(mod b)的线性同余方程，根据模运算的定义，在方程左侧添加一个by不会对结果造成影响，其实质就等价于ax+by=c的不定方程，利用上述方法求解便可。</p>
<h2 id="求二元一次方程-线性同余方程通解"><a href="#求二元一次方程-线性同余方程通解" class="headerlink" title="求二元一次方程/线性同余方程通解"></a>求二元一次方程/线性同余方程通解</h2><p>设g=gcd(a,b), a’=b/g, b’=a/g， x0,y0为方程的一组特解， 则通解为x=x0+a’t, y=y0-b’t(t为整数)</p>
<p><strong>证明</strong><br>Q:为什么它是通解？<br>A:因为将该解代入方程恒成立<br>Q:但还有其他形式的解能满足，例如x=x0+b<em>t, y=y0-a</em>t,为什么选他呢?<br>A:因为他能无遗漏地表示所有正整数解，因为lcm(a,b)=ab/g, x,y的系数分别为a,b,所以x,y的在满足方程的前提下的最小变化量为b/g,a/g,证毕。<br><strong>线性同余方程同理</strong></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>至此我们具备了解决问题所需要的所有知识<br><strong>无整数解：</strong> 要求输出-1。根据扩展欧几里得算法的定义可得，当c%gcd(a,b)≠0时方程无整数解，输出-1即可。<br><strong>判断有无正整数解：</strong> 根据二元一次方程的通解可得，x,y的增减性相反，所以若存在正整数解，则当x取得最小正整数解时，y取得最大正整数解，若此时y≤0,则说明该方程无正整数解。最小整数解可以通过取余快速得到，如x的最小整数解为(x0%a’+a’)%a’,这里需要特判下，当x=0时另x=a’,y同理。<br><strong>解组个数：</strong> 易得正整数解的组数为(Xmax-Xmin)/a’+1或(Ymax-Ymin)/b’+1.</p>
<p><strong>Code：</strong></p>
<pre><code>#include&lt;cstdio&gt;
#define ll long long    //注意开long long

ll read(){
    char ch;
    ll num=0;
    ch=getchar();
    while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)
        ch=getchar();
    while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;){
        num=num*10+ch-&apos;0&apos;;
        ch=getchar();
    }
    return num;
}

ll ex_gcd(ll a,ll b,ll &amp;x,ll &amp;y){
    if(b==0){
        x=1, y=0;
        return a;
    }
    ll k=ex_gcd(b,a%b,x,y);
    ll temp=x;
    x=y;
    y=temp-a/b*y;
    return k;
}

int main(){
    ll n,x,y,a,b,c,d;
    n=read();
    while(n--){
        a=read(), b=read(), c=read();
        d=ex_gcd(a,b,x,y);
        if(c%d!=0){
            printf(&quot;-1\n&quot;);
            continue;
        }
        x*=c/d, y*=c/d;
        ll temp=(x%(b/d)+b/d)%(b/d);    //temp为x的最小正整数解
        if(temp==0)                //特判
            temp=b/d;
        if((c-a*temp)/b&lt;=0){
            int q=(y%(a/d)+a/d)%(a/d);    //q为y的最小正整数解
            if(!q)
                q=a/d;
            printf(&quot;%lld %lld\n&quot;,temp,q);
            continue;
        }
        ll temp2=(y%(a/d)+a/d)%(a/d);    //temp2为y的最小正整数解
        if(!temp2)
            temp2=a/d;
        int maxx=(c-temp2*b)/a;        //maxx为x的最大正整数解
        printf(&quot;%lld %lld %lld %lld %lld\n&quot;,(maxx-temp)/(b/d)+1,temp,temp2,maxx,(c-temp*a)/b);
    }
    return 0;
}</code></pre><p><strong>此题为洛谷P5656，建议去洛谷切下这道题来巩固，洛谷CF7C Line为弱化版，只用找出一组整数解即可</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/Splay%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/Splay%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Splay入门详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 21:52:30" itemprop="dateCreated datePublished" datetime="2020-04-12T21:52:30+08:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-25 11:14:20" itemprop="dateModified" datetime="2020-04-25T11:14:20+08:00">2020-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B3%E8%A1%A1%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">平衡树</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B3%E8%A1%A1%E6%A0%91/Splay/" itemprop="url" rel="index"><span itemprop="name">Splay</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="普通平衡树（splay）"><a href="#普通平衡树（splay）" class="headerlink" title="普通平衡树（splay）"></a>普通平衡树（splay）</h1><p><strong>前言</strong></p>
<p>本篇讲解内容转自<a href="https://www.luogu.com.cn/blog/user19027/solution-p3369" target="_blank" rel="noopener">rtldl的博客</a>，其中添加了些个人理解，希望能帮助你更好的了解Splay。个人认为Splay并没有那么难，跟树剖一样属于虽然码量不小但只要理解了思路就不难实现的一类数据结构，所以当你看到下面的长篇大论时请一定要坚持看下去，你会发现其实每一步都是很好理解的，最后祝你食用愉快！</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>对于Splay，我定义了一个class类（当成struct就行啦。。。个人习惯不同啦），定义名称为“Splay”。</p>
<p>之后在类中，我定义了Splay的主体，即数组e。</p>
<p>e的类型是node类型，包含节点值（v）、父级节点（father）、左孩子（ch[0]）、右孩子（ch[1]）、包含自己在内的下面共有多少元素（sum）（注意是元素啊！！！不是节点！！！）、该节点所表示的元素出现的次数（recy）。</p>
<p>之后，还在类中定义了n代表当前已经使用的数组编号。points代表整个树总共有多少元素（注意是元素啊！！！不是节点！！！）。</p>
<p>另外，整棵树中，有一个超级根e[0]，其右孩子即为树的根。</p>
<p>宏定义了e[0].ch[1]为root，方便访问、理解。并在类的末尾取消定义root，确保外部再定义root变量时不会出现问题，维持其模块性质。</p>
<pre><code>class Splay//存储规则：小左大右，重复节点记录 
{
    #define root e[0].ch[1]   //该树的根节点
    private:
        class node
        {
            public:
                int v,father;//节点值，父级节点 
                int ch[2];//左孩子=0，右孩子=1
                int sum;//自己+自己下级有多少节点。在根节点为1。
                int recy;//记录自己被重复了几次
        };        
node e[MAXL];//Splay树主体
        int n,points;//使用存储数,元素数
    ……
    #undef root
};</code></pre><h2 id="功能全解"><a href="#功能全解" class="headerlink" title="功能全解"></a>功能全解</h2><h2 id="更新当前节点sum值-update"><a href="#更新当前节点sum值-update" class="headerlink" title="更新当前节点sum值(update)"></a>更新当前节点sum值(update)</h2><p>就是在进行了连接、插入、删除等操作以后使用的一个维护性质的函数。用来确定被update的节点的sum值。</p>
<pre><code>void update(int x)
{
    e[x].sum=e[e[x].ch[0]].sum+e[e[x].ch[1]].sum+e[x].recy;
}</code></pre><h2 id="获取父子关系-identify"><a href="#获取父子关系-identify" class="headerlink" title="获取父子关系(identify)"></a>获取父子关系(identify)</h2><p>用来确定当前节点到底是父亲的左孩子（0）还是右孩子（1）。</p>
<pre><code>int identify(int x)
{
    return e[e[x].father].ch[0]==x?0:1;
}</code></pre><h2 id="建立父子关系-connect"><a href="#建立父子关系-connect" class="headerlink" title="建立父子关系(connect)"></a>建立父子关系(connect)</h2><p>用来连接两个点，其中一个点为另一个点的孩子。</p>
<p>注意，这个操作并不能将其他的父子关系一并断开。因为他们与被操作的两个点没有直接的数据联系。例如下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsuGE4.png" alt="12"></p>
<p>图表明尽管B的父亲已经不是x，但是x的右孩子依旧是B，没有被更新。因此使用过程中应当有更巧妙的设计来避免这样导致的错误发生。</p>
<pre><code>void connect(int x,int f,int son)//连接函数。用法：connect(son,father,左儿子（0）或右儿子（1）)
{
    e[x].father=f;
    e[f].ch[son]=x;
}//作用：将x连接在f的下方。连接方向由son的值决定。</code></pre><h2 id="旋转节点-rotate"><a href="#旋转节点-rotate" class="headerlink" title="旋转节点(rotate)"></a>旋转节点(rotate)</h2><p>着重注意的一个函数。这个函数同时实现了左旋和右旋。</p>
<p>所谓的旋转，其实就是指将被指定的节点向上移动一级，并将原有的父级节点作为自己的儿子。如下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsuyUH.png" alt="12"></p>
<p>我们可以通过下图原理论证来确定只需要三次connect即可完成旋转。</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Jsu28I.png" alt="12"></p>
<p>上图代表了右旋。</p>
<p>在图中，A、B、C代表三个子树（可以是空的），x和y代表被旋转的节点。R为y的上级节点，与旋转没有直接关系，但是它的右孩子要进行相应的改变。</p>
<p>在进行完connect函数后，再进行update函数即可完成旋转。</p>
<p>但是旋转总共有两种类型的操作（即左旋和右旋）。在这里，我们需要配合位运算直接达到自动判断和旋转方向决断的目的。</p>
<p>我们知道，对于任意一个自然数，与1进行逻辑异或运算，会得到这样的结果：</p>
<p>0^1=1 1^1=0 2^1=3 3^1=2 4^1=5 5^1=4 ……</p>
<p>也就是说，0对应1，2对应3，4对应5，向后依次推。</p>
<p>既然这样，那么我们的左右儿子节点所代表的编号分别是0和1。也就是说对其中一个取逻辑异或，会得到另一个儿子的标号（即对0取逻辑异或得1，对1取逻辑异或得0）。</p>
<p>通过左旋右旋的性质可以知道，实际改变了父子关系的节点是上图的：x、y、B节点。因为实际上，A、C节点的父子关系并没有发生任何改变。</p>
<p>并且我们能够注意到，x与y节点的连接方向一定是与x和B的连接方向不同的。</p>
<p>那么，我们只需要先通过“identify”函数确定x与y的父子关系，确定到底要向那一边旋转（如果x是y的左孩子，那么就向右旋转。如果x是y的右孩子，那么就向左旋转），然后通过逻辑异或来确定子树“B”究竟应当被连接在y的哪一侧。</p>
<pre><code>void rotate(int x)
{
    int y=e[x].father;
    int mroot=e[y].father;
    int mrootson=identify(y);
    int yson=identify(x);
    int B=e[x].ch[yson^1];
    connect(B,y,yson);connect(y,x,(yson^1));connect(x,mroot,mrootson);
    update(y);update(x);
}</code></pre><h2 id="伸展操作-splay"><a href="#伸展操作-splay" class="headerlink" title="伸展操作(splay)"></a>伸展操作(splay)</h2><p>其实就是考虑上旋节点的方式。</p>
<p>在这里，一开始我使用了一种较为偷懒的旋转方式，即能向上旋转就向上旋转。并不考虑上面的状况到底怎样。</p>
<p>其实，标准的写法中，需要考虑两种情况。如下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsuR2t.png" alt="12"></p>
<p>为了防止造成误导，我将不再介绍直接上旋的操作。但事实上，无论是直接上旋还是先判断再上旋，都会有可能进化或者退化原本的树形结构。</p>
<p>我也曾举出过两种操作模式各自进化或者退化树的例子。但是根据交题情况，在洛谷的模板题中，直接上旋的速度更快。然而在湖南的一道省选题中，使用直接上旋的模式却直接导致超时（大概慢了10倍）。所以说在面对大数据的不确定因素下，还是应当选择考虑更多种情况，而不能图方便。</p>
<p>在这里，我的函数实现的操作是：将at节点旋转到to节点所在的位置。</p>
<pre><code>void splay(int at,int to)
{
    to=e[to].father;
    while(e[at].father!=to)
    {
        int up=e[at].father;
        if(e[up].father==to) rotate(at);
        else if(identify(up)==identify(at))
        {//对应图中case1
            rotate(up);
            rotate(at);
        }
        else
        {//对应图中case2
            rotate(at);
            rotate(at);
        }
    }
}</code></pre><h2 id="添加节点-crepoint-和摧毁节点-destroy"><a href="#添加节点-crepoint-和摧毁节点-destroy" class="headerlink" title="添加节点(crepoint)和摧毁节点(destroy)"></a>添加节点(crepoint)和摧毁节点(destroy)</h2><p>这两个操作是在插入新元素和删除元素过程中使用的函数。</p>
<p>crepoint的作用是获得一个新的树存储位置，然后为这个存储空间写入基本的信息，并返回使用的存储位置编号。</p>
<p>destroy的作用则是使得一个节点完全失效，完全抹除节点信息，防止其他意外的发生。并且添加了一个小小的优化：如果被抹除的节点恰好是存储数组的当前最后一个元素，那么就对存储空间的使用数减1。</p>
<p>实际上，也可以通过一个队列来确定那些节点在中间被挖空了。但这样的操作不仅要牺牲一个O(log N)的时间复杂度，而且事实上并没有太大的用处，因为你开的数组大小一定能够满足极端情况（比如说所有操作都是插入）。</p>
<pre><code>int crepoint(int v,int father)
{
    n++;
    e[n].v=v;
    e[n].father=father;
    e[n].sum=e[n].recy=1;
    return n;
}
void destroy(int x) 
{
    e[x].v=e[x].ch[0]=e[x].ch[1]=e[x].sum=e[x].father=e[x].recy=0;
    if(x==n) n--;
}</code></pre><h2 id="查找元素-find"><a href="#查找元素-find" class="headerlink" title="查找元素(find)"></a>查找元素(find)</h2><p>要实现的功能是找特定值是否在树中以及对应的节点编号。</p>
<p>很简单的实现方式。从根开始向下移动，如果要找的元素比当前节点小，那么就转到自己的左孩子。否则，就转向自己的右孩子，直到节点值等于要找的值。</p>
<p>如果在找到目标值之前，需要走的路已经无法再走（比如说现在到了5，要找的是3，应该往左走，但是5已经没有左孩子了），那么则查找失败，返回失败值（0）。如果查找成功，则返回节点对应的编号。</p>
<p>查找结束后，将被查找的节点旋转到根，以保证树的结构随机性。</p>
<pre><code>int find(int v) 
{
    int now=root;
    while(true)
    {
        if(e[now].v==v)
        {
            splay(now,root);
            return now;
        }
        int next=v&lt;e[now].v?0:1;
        if(!e[now].ch[next]) return 0;
        now=e[now].ch[next];
    }
}</code></pre><p>建树(build)</p>
<p>建树的功能我并没有看懂大佬们的操作到底是什么意思。。。（我觉得应该是将Splay用作线段树的时候使用的功能）所以我写了一个没有上旋操作的insert函数。</p>
<p>首先，从根开始，向下寻找。如果要插入的元素已经在树中，那么将这个节点的recy加1即可。如果没有出现过，那么找一个合适的空的位置。找到位置后，调用crepoint函数，在数组中申请一个新的下标存储元素。</p>
<p>同时注意，在向下寻找的过程中，对被经过的点的sum值加1，因为如果经过这个点，代表要加的点肯定在自己下面，所以自己下面的元素个数加1。</p>
<pre><code>int build(int v)//内部调用的插入函数，没有splay 
{
    points++;
    if(n==0)//特判无点状态 
    {
        root=1;
        crepoint(v,0);
    }
    else
    {
        int now=root;
        while(true)//向下找到一个空节点 
        {
            e[now].sum++;//自己的下级肯定增加了一个节点 
            if(v==e[now].v)
            {
                e[now].recy++;
                return now;
            }
            int next=v&lt;e[now].v?0:1;
            if(!e[now].ch[next])
            {
                crepoint(v,now);
                e[now].ch[next]=n;
                return n;
            }
            now=e[now].ch[next];
        }
    }
    return 0;
}</code></pre><h2 id="插入节点-push"><a href="#插入节点-push" class="headerlink" title="插入节点(push)"></a>插入节点(push)</h2><p>就是在进行完build操作以后，执行一次上旋操作，确保树的结构随机性。</p>
<pre><code>void push(int v)
{
    int add=build(v);
    splay(add,root);
}</code></pre><h2 id="删除节点-pop"><a href="#删除节点-pop" class="headerlink" title="删除节点(pop)"></a>删除节点(pop)</h2><p>将输入值对应的节点在树中移除。</p>
<p>进行这样的操作时，我一开始考虑的是通过逐层的rotate操作将要被删除的节点转到最下方，然后再删除，最后逐层向上改变路径上的sum值。但是考虑到这样的操作可能会一方面导致树的大幅度退化，另一方面相当于要进行两次O(log N)的时间复杂度操作，常数略大，可能会成为一颗定时炸弹。所以为了稳定，还是用了常规的方法：</p>
<p>首先将要删除的节点旋转到根节点的位置。</p>
<p>然后，判断情况：如果要被删除的节点（注意现在它在根的位置）没有左孩子，那么直接摧毁这个节点，并将它的右孩子变成根。</p>
<p>如果自己有左孩子，那么就先把左子树中值最大的元素旋转到根的左孩子位置，然后将根节点的右孩子变成根节点的左孩子的右孩子，然后摧毁节点，并将左孩子变成根。</p>
<p>原理还请读者自己考虑吧，根据二叉排序树的性质。。。</p>
<pre><code>void pop(int v)//删除节点 
{
    int deal=find(v);
    if(!deal) return;
    points--;
    if(e[deal].recy&gt;1)
    {
        e[deal].recy--;
        e[deal].sum--;
        return;
    }
    if(!e[deal].ch[0])
    {
        root=e[deal].ch[1];
        e[root].father=0;
    }
    else
    {
        int lef=e[deal].ch[0];
        while(e[lef].ch[1]) lef=e[lef].ch[1];
        splay(lef,e[deal].ch[0]);
        int rig=e[deal].ch[1];
        connect(rig,lef,1);connect(lef,0,1);
        update(lef);
    }
    destroy(deal);
}</code></pre><h2 id="获取元素的排名（rank）-amp-获取该排名对应的元素值（atrank）"><a href="#获取元素的排名（rank）-amp-获取该排名对应的元素值（atrank）" class="headerlink" title="获取元素的排名（rank）&amp;获取该排名对应的元素值（atrank）"></a>获取元素的排名（rank）&amp;获取该排名对应的元素值（atrank）</h2><p>两个函数是互逆的函数。</p>
<p>rank的实现根find差不多，只是在向下走的时候，对于当前已经记录的rank值进行更新（每次调用rank时都初始化为0）。规则是：向左走时，rank值不发生任何改变。向右走之前，要先给rank加上当前节点的左孩子的sum值和recy值。找到对应元素时，再对rank+1。如下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Jsu4r8.png" alt="12"></p>
<p>atrank函数根rank实现完全相反。在向下走的过程中，如果要找的排名大于当前点左子树的sum值，并且小于等于当前点的左子树的sum加上本节点的recy的值，那么当前的点就是要找的点。如果小于上述范围，就往左走，反之向右。注意向右走的过程中，将要查询的排名值减少上述范围的最大值。</p>
<p>两个操作结束后，都要将被操作的节点旋转到根。</p>
<pre><code>int rank(int v)//获取值为v的元素在这棵树里是第几小 
{
    int ans=0,now=root;
    while(true)
    {
        if(e[now].v==v) return ans+e[e[now].ch[0]].sum+1;
        if(now==0) return 0;
        if(v&lt;e[now].v) now=e[now].ch[0];
        else
        {
            ans=ans+e[e[now].ch[0]].sum+e[now].recy;
            now=e[now].ch[1];
        }
    }
    if(now) splay(now,root);
    return 0;
}
int atrank(int x)//获取第x小的元素的值 
{
    if(x&gt;points) return -INF;
    int now=root;
    while(true)
    {
        int minused=e[now].sum-e[e[now].ch[1]].sum;
        if(x&gt;e[e[now].ch[0]].sum&amp;&amp;x&lt;=minused) break;
        if(x&lt;minused) now=e[now].ch[0];
        else
        {
            x=x-minused;
            now=e[now].ch[1];
        }
    }
    splay(now,root);
    return e[now].v;
}</code></pre><h2 id="查找前驱（lower）和后继（upper）"><a href="#查找前驱（lower）和后继（upper）" class="headerlink" title="查找前驱（lower）和后继（upper）"></a>查找前驱（lower）和后继（upper）</h2><p>两种操作是类似的操作。</p>
<p>前驱是指在树中，小于这个值并且最接近这个值的元素值。</p>
<p>后继则是大于这个值并且最接近这个值的元素值。</p>
<p>对于这两种函数的实现方式，就是先初始化一个最值，然后在向下走的过程中，如果发现了符合要求且更优的值，就用更优值替换当前的值。最后不能走的时候输出这个值即可。</p>
<pre><code>int upper(int v) 
{
    int now=root;
    int result=INF;
    while(now)
    {
        if(e[now].v&gt;v&amp;&amp;e[now].v&lt;result) result=e[now].v;
        if(v&lt;e[now].v) now=e[now].ch[0];
        else now=e[now].ch[1];
    }
    return result;
}
int lower(int v) 
{
    int now=root;
    int result=-INF;
    while(now)
    {
        if(e[now].v&lt;v&amp;&amp;e[now].v&gt;result) result=e[now].v;
        if(v&gt;e[now].v) now=e[now].ch[1];
        else now=e[now].ch[0];
    }
    return result;</code></pre><p>完结撒花~  恭喜你坚持了下来，至此你应该对Splay有了大致的了解，其中的思路大致如此，具体的实现会因人而异，下面我将贴上另一种Splay实现，思路都是一样的，细节实现稍有不同<br>，你可以与上面的代码作对比，并加深理解。</p>
<pre><code>#include&lt;cstdio&gt;
#define maxn 200500

int n,opt,cnt,root;
int val[maxn],son[maxn][2],fa[maxn],size[maxn],sum[maxn];

inline void destroy(int u){
    val[u] = son[u][0] = son[u][1] = fa[u] = sum[u] = size[u] = 0;
}

inline int identify(int u){
    return son[fa[u]][1] == u;
}

inline void update(int u){
    if(u)
        sum[u] = sum[son[u][0]]+sum[son[u][1]]+size[u];
}

void rotate(int u){
    int f = fa[u],gf = fa[f],sta = identify(u),sta_f = identify(f);
    son[f][sta] = son[u][sta^1];
    fa[son[f][sta]] = f;
    son[u][sta^1] = f,fa[f] = u,fa[u] = gf;
    son[gf][sta_f] = u;
    update(f),update(u);
}

void splay(int u){
    for(int f;f = fa[u];rotate(u))
        if(fa[f])
            rotate(identify(u)==identify(f) ? f:u);
    root = u;
}

void insert(int u){
    if(!root){
        val[++cnt] = u;
        size[cnt] = sum[cnt] = 1;
        root = cnt;
        return ;
    }
    int now = root,f = 0;
    while(true){
        if(u == val[now]){
            ++size[now];
            update(now),update(f);
            splay(now);
            return ;
        }
        f = now,now = son[now][val[now]&lt;u];
        if(!now){
            val[++cnt] = u;
            size[cnt] = sum[cnt] = 1;
            fa[cnt] = f,son[f][val[f]&lt;u] = cnt;
            ++sum[f];
            splay(cnt);
               return ;
        }
    }
}

int find_num(int u){
    int now = root;
    while(true){
        if(son[now][0]&amp;&amp;u &lt;= sum[son[now][0]])
            now = son[now][0];
        else{
            int temp = sum[son[now][0]]+size[now];
            if(u &lt;= temp)
                return val[now];
            now = son[now][1],u -= temp;
        }
    }
}

int find_rank(int u){
    int now = root,rank = 0;
    while(true){
        if(u &lt; val[now])
            now = son[now][0];
        else{
            rank += sum[son[now][0]];
            if(u == val[now]){
                splay(now);
                return rank+1;
            }
            rank += size[now],now = son[now][1];
        }
    }
}

int find_pre(){     //注意这里查找前驱后继的函数和上面不一样，实现思路见下面主函数里的注释    
    int now = son[root][0];
    while(son[now][1])
        now = son[now][1];
    return now;
}

int find_suffix(){
    int now = son[root][1];
    while(son[now][0])
        now = son[now][0];
        return now;
}

void delete_val(int u){        //按照二叉搜索树(BST)的思路删点
    find_rank(u);
    if(size[root] &gt; 1){
        --size[root],--sum[root];
        return ;
    }
    if(!son[root][0] &amp;&amp; !son[root][1]){
        destroy(root),root = 0;
        return ;
    }
    int old_root = root;
    if(!son[root][0]){
        root = son[root][1];
        fa[root] = 0;
        destroy(old_root);
        return ;
    }
    if(!son[root][1]){
        root = son[root][0];    
        fa[root] = 0;
        destroy(old_root);
        return ;
    }
    int left_max = find_pre();
    splay(left_max);
    son[root][1] = son[old_root][1];
    fa[son[old_root][1]] = root;
    destroy(old_root);
    update(root);
}    

int main(){
    int x;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--){
        scanf(&quot;%d%d&quot;,&amp;opt,&amp;x);
        if(opt == 1)
            insert(x);
        else if(opt == 2)
            delete_val(x);
        else if(opt == 3)
            printf(&quot;%d\n&quot;,find_rank(x));
        else if(opt == 4)
            printf(&quot;%d\n&quot;,find_num(x));
        else if(opt == 5){  //与上面不同，5和6操作是先插入要删除的值，目的是将储存该值的节点上旋到跟节点，这样左子树的最大值就是答案。
            insert(x);
            printf(&quot;%d\n&quot;,val[find_pre()]);
            delete_val(x);
        }
        else{
            insert(x);
            printf(&quot;%d\n&quot;,val[find_suffix()]);
            delete_val(x);
        }
    }
    return 0;
}</code></pre><p>最后再奉上一道练习题，这道题也可以当做线段树合并的入门题。</p>
<p><a href="https://www.luogu.com.cn/problem/P3224" target="_blank" rel="noopener">洛谷p3224永无乡</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/%E4%B8%BB%E5%B8%AD%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/%E4%B8%BB%E5%B8%AD%E6%A0%91/" class="post-title-link" itemprop="url">主席树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-05 16:54:33" itemprop="dateCreated datePublished" datetime="2020-04-05T16:54:33+08:00">2020-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-25 09:32:22" itemprop="dateModified" datetime="2020-04-25T09:32:22+08:00">2020-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">线段树</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="可持久化线段树（主席树）"><a href="#可持久化线段树（主席树）" class="headerlink" title="可持久化线段树（主席树）"></a>可持久化线段树（主席树）</h1><h2 id="前置芝士-：-线段树，离散化（部分题目需要）"><a href="#前置芝士-：-线段树，离散化（部分题目需要）" class="headerlink" title="前置芝士   ：  线段树，离散化（部分题目需要）"></a>前置芝士   ：  线段树，离散化（部分题目需要）</h2><blockquote>
<p><a href="https://www.cnblogs.com/TenosDoIt/p/3453089.html" target="_blank" rel="noopener">如果还不了解线段树可以戳这里</a></p>
</blockquote>
<p>主席树是一种以线段树为基础的可以快速查询区间第k小（大）的数据结构，其中可持久化的意思就是对于每次修改，我们都将结果保存下来，然后你可以随时查询修改之前任意一次操作时所对应的线段树，类似于git，可以查看历史版本。为了实现这一功能，容易想到的是暴力建树，即对于每次操作都重新建立一颗线段树，但这样做时间空间肯定会炸的稀里哗啦。于是我们换个角度想，考虑到对于每次修改，实际变动的节点只是少数，如下图：<br><img src="https://s1.ax1x.com/2020/04/25/JsC74O.png" alt="233"></p>
<p>假如现在正在进行第x次操作，我们对原序列第四个点进行修改，其中橙色节点是第x-1次操作对应的线段树的节点，而其右边是第x次操作新建立的线段树节点。这里若修改第4个点，则只有橙色的节点维护的信息发生了变动，而其他节点都保持不变，考虑到这一特点，在每次修改后，我们只需要创建与受到影响的节点（橙色节点）相对应的节点（橙色节点右边的节点），然后让他们共用那些没有被影响的节点，这样一来，便可以很快的建好第x次操作所对应的线段树，并且极大节约了空间。（与普通线段树不同的是，节点的左右儿子编号并不能被计算出来，需要另行记录）</p>
<p>下面我们通过一道例题具体实现下，此题需进行离散化 <a href="https://www.cnblogs.com/lornd/p/11167316.html" target="_blank" rel="noopener">可参考这篇博客的方法二</a></p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">例题 洛谷p3834</a></p>
</blockquote>
<p>题意<br>给定 n 个整数构成的序列，将对于指定的闭区间查询其区间内的第 k 小值。</p>
<p>输入格式<br>第一行包含两个正整数 n,mn,m，分别表示序列的长度和查询的个数。</p>
<p>第二行包含 nn 个整数，表示这个序列各项的数字。</p>
<p>接下来 mm 行每行包含三个整数 l, r, kl,r,k , 表示查询区间 [l, r][l,r] 内的第 kk 小值。</p>
<p>输出格式<br>输出包含 mm 行，每行一个整数，依次表示每一次查询的结果</p>
<p>数据范围<br>1 &lt;= n,m &lt;= 2*10^5  数列中的所有数绝对值都不超过10^9</p>
<p>这是一道板子题，我将结合代码用注释解释</p>
<p><strong>Code</strong></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define maxn 200005
using std::sort;
using std::unique;
using std::lower_bound;

int n,m,cnt,p,k,l,r;
int cl[maxn&lt;&lt;5],cr[maxn&lt;&lt;5],sum[maxn&lt;&lt;5];
//cl[i],cr[i],sun[i]分别为i号节点的左孩子序号,右孩子序号,i号节点管理的区间和
int rt[maxn],a[maxn],b[maxn];
//rt[i]是第i颗线段树的根节点号码，a,b分别是原数组和其副本
int change(int u,int l,int r){    //u是与现在访问的节点相对应的上一颗数的节点号码，l,r是该号码所管理的区间
    int t = ++cnt;    //t是新建立的节点号码
    cl[t] = cl[u],cr[t] = cr[u],sum[t] = sum[u]+1; //先让t号节点继承上一颗线段树与之对应的节点的信息
    if(l == r)        //该节点没有孩子了，结束更新
        return t;
    int mid = (l+r)&gt;&gt;1;
    if(p &lt;= mid)    //变动的节点在左子树，递归进入左子树创立新节点
        cl[t] = change(cl[u],l,mid);
    else
        cr[t] = change(cr[u],mid+1,r);
    return t;    //返回这次创立的节点序号
}

int query(int fu,int u,int l,int r,int k){    //返回第k小的数离散化后的rank
    if(l == r)
        return l;
    int mid = (l+r)&gt;&gt;1,num = sum[cl[u]]-sum[cl[fu]];    //主席树是可减的，这里实际模拟下就很清楚了
    if(num &gt;= k)
        return query(cl[fu],cl[u],l,mid,k);
    else
        return query(cr[fu],cr[u],mid+1,r,k-num);
}

int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i = 1;i &lt;= n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
        b[i] = a[i];    //因为要进行离散化，而之后还要用该数组的值，所以创建副本
    }
    //   下面是离散化操作
    sort(b+1,b+1+n);
    int len = unique(b+1,b+1+n)-b-1;
    for(int i = 1;i &lt;= n;i++){        //对原数组下标1-i的数建一颗线段树（也就是一个版本），一共会建立n颗线段树
        p = lower_bound(b+1,b+1+len,a[i])-b;
        rt[i] = change(rt[i-1],1,len);    //change函数会创建新节点，同时返回新创建的节点标号
    }
    while(m--){
        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);
        int t = query(rt[l-1],rt[r],1,len,k);
        printf(&quot;%d\n&quot;,b[t]);
    }
    return 0;
}</code></pre><p>下面放两道主席树的其他类型题目：<br>洛谷 p3919<br>洛谷 p3402</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/%E7%BD%91%E7%BB%9C%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/%E7%BD%91%E7%BB%9C%E6%B5%81/" class="post-title-link" itemprop="url">网络流</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 15:53:38" itemprop="dateCreated datePublished" datetime="2020-03-21T15:53:38+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-26 09:47:40" itemprop="dateModified" datetime="2020-03-26T09:47:40+08:00">2020-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><em>以网络流24题为例</em></strong></p>
<blockquote>
<p>匹配</p>
<blockquote>
<p>二分图匹配<br>    1.匈牙利算法<br>一般图最大匹配<br>    1.带花树算法</p>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/%E6%89%AB%E6%8F%8F%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/%E6%89%AB%E6%8F%8F%E7%BA%BF/" class="post-title-link" itemprop="url">扫描线</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 15:47:54" itemprop="dateCreated datePublished" datetime="2020-03-21T15:47:54+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-26 09:46:55" itemprop="dateModified" datetime="2020-03-26T09:46:55+08:00">2020-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前置知识：线段树-离散化"><a href="#前置知识：线段树-离散化" class="headerlink" title="前置知识：线段树  离散化"></a><strong>前置知识：线段树  离散化</strong></h2><blockquote>
<p>123</p>
<blockquote>
<p>456</p>
<ol>
<li>456</li>
<li>789</li>
</ol>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/Hello-World/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/Hello-World/" class="post-title-link" itemprop="url">Hello World</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 15:22:32" itemprop="dateCreated datePublished" datetime="2020-03-20T15:22:32+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-21 16:40:33" itemprop="dateModified" datetime="2020-03-21T16:40:33+08:00">2020-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><em>hello people</em></strong></p>
<blockquote>
<ul>
<li>欢迎光临*<blockquote>
<ul>
<li>123</li>
<li>456</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_Nice</p>
  <div class="site-description" itemprop="description">你只有十分努力，才能看上去毫不费力</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_Nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
