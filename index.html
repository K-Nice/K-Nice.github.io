<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="你只有十分努力，才能看上去毫不费力">
<meta property="og:type" content="website">
<meta property="og:title" content="_Niceの博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="_Niceの博客">
<meta property="og:description" content="你只有十分努力，才能看上去毫不费力">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="_Nice">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>_Niceの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">_Niceの博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">think twice,code once</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/Splay%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/Splay%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Splay入门详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 21:52:30" itemprop="dateCreated datePublished" datetime="2020-04-12T21:52:30+08:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-17 10:24:38" itemprop="dateModified" datetime="2020-04-17T10:24:38+08:00">2020-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B3%E8%A1%A1%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">平衡树</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B3%E8%A1%A1%E6%A0%91/Splay/" itemprop="url" rel="index"><span itemprop="name">Splay</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="普通平衡树（splay）"><a href="#普通平衡树（splay）" class="headerlink" title="普通平衡树（splay）"></a>普通平衡树（splay）</h1><p><strong>前言</strong></p>
<p>本篇讲解内容转自<a href="https://www.luogu.com.cn/blog/user19027/solution-p3369" target="_blank" rel="noopener">rtldl的博客</a>，其中添加了些个人理解，希望能帮助你更好的了解Splay。个人认为Splay并没有那么难，跟树剖一样属于虽然码量不小但只要理解了思路就不难实现的一类数据结构，所以当你看到下面的长篇大论时请一定要坚持看下去，你会发现其实每一步都是很好理解的，最后祝你食用愉快！</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>对于Splay，我定义了一个class类（当成struct就行啦。。。个人习惯不同啦），定义名称为“Splay”。</p>
<p>之后在类中，我定义了Splay的主体，即数组e。</p>
<p>e的类型是node类型，包含节点值（v）、父级节点（father）、左孩子（ch[0]）、右孩子（ch[1]）、包含自己在内的下面共有多少元素（sum）（注意是元素啊！！！不是节点！！！）、该节点所表示的元素出现的次数（recy）。</p>
<p>之后，还在类中定义了n代表当前已经使用的数组编号。points代表整个树总共有多少元素（注意是元素啊！！！不是节点！！！）。</p>
<p>另外，整棵树中，有一个超级根e[0]，其右孩子即为树的根。</p>
<p>宏定义了e[0].ch[1]为root，方便访问、理解。并在类的末尾取消定义root，确保外部再定义root变量时不会出现问题，维持其模块性质。</p>
<pre><code>class Splay//存储规则：小左大右，重复节点记录 
{
    #define root e[0].ch[1]   //该树的根节点
    private:
        class node
        {
            public:
                int v,father;//节点值，父级节点 
                int ch[2];//左孩子=0，右孩子=1
                int sum;//自己+自己下级有多少节点。在根节点为1。
                int recy;//记录自己被重复了几次
        };        
node e[MAXL];//Splay树主体
        int n,points;//使用存储数,元素数
    ……
    #undef root
};</code></pre><h2 id="功能全解"><a href="#功能全解" class="headerlink" title="功能全解"></a>功能全解</h2><h2 id="更新当前节点sum值-update"><a href="#更新当前节点sum值-update" class="headerlink" title="更新当前节点sum值(update)"></a>更新当前节点sum值(update)</h2><p>就是在进行了连接、插入、删除等操作以后使用的一个维护性质的函数。用来确定被update的节点的sum值。</p>
<pre><code>void update(int x)
{
    e[x].sum=e[e[x].ch[0]].sum+e[e[x].ch[1]].sum+e[x].recy;
}</code></pre><h2 id="获取父子关系-identify"><a href="#获取父子关系-identify" class="headerlink" title="获取父子关系(identify)"></a>获取父子关系(identify)</h2><p>用来确定当前节点到底是父亲的左孩子（0）还是右孩子（1）。</p>
<pre><code>int identify(int x)
{
    return e[e[x].father].ch[0]==x?0:1;
}</code></pre><h2 id="建立父子关系-connect"><a href="#建立父子关系-connect" class="headerlink" title="建立父子关系(connect)"></a>建立父子关系(connect)</h2><p>用来连接两个点，其中一个点为另一个点的孩子。</p>
<p>注意，这个操作并不能将其他的父子关系一并断开。因为他们与被操作的两个点没有直接的数据联系。例如下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/4409.png" alt="12"></p>
<p>图表明尽管B的父亲已经不是x，但是x的右孩子依旧是B，没有被更新。因此使用过程中应当有更巧妙的设计来避免这样导致的错误发生。</p>
<pre><code>void connect(int x,int f,int son)//连接函数。用法：connect(son,father,左儿子（0）或右儿子（1）)
{
    e[x].father=f;
    e[f].ch[son]=x;
}//作用：将x连接在f的下方。连接方向由son的值决定。</code></pre><h2 id="旋转节点-rotate"><a href="#旋转节点-rotate" class="headerlink" title="旋转节点(rotate)"></a>旋转节点(rotate)</h2><p>着重注意的一个函数。这个函数同时实现了左旋和右旋。</p>
<p>所谓的旋转，其实就是指将被指定的节点向上移动一级，并将原有的父级节点作为自己的儿子。如下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/4410.png" alt="12"></p>
<p>我们可以通过下图原理论证来确定只需要三次connect即可完成旋转。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/4411.png" alt="12"></p>
<p>上图代表了右旋。</p>
<p>在图中，A、B、C代表三个子树（可以是空的），x和y代表被旋转的节点。R为y的上级节点，与旋转没有直接关系，但是它的右孩子要进行相应的改变。</p>
<p>在进行完connect函数后，再进行update函数即可完成旋转。</p>
<p>但是旋转总共有两种类型的操作（即左旋和右旋）。在这里，我们需要配合位运算直接达到自动判断和旋转方向决断的目的。</p>
<p>我们知道，对于任意一个自然数，与1进行逻辑异或运算，会得到这样的结果：</p>
<p>0^1=1 1^1=0 2^1=3 3^1=2 4^1=5 5^1=4 ……</p>
<p>也就是说，0对应1，2对应3，4对应5，向后依次推。</p>
<p>既然这样，那么我们的左右儿子节点所代表的编号分别是0和1。也就是说对其中一个取逻辑异或，会得到另一个儿子的标号（即对0取逻辑异或得1，对1取逻辑异或得0）。</p>
<p>通过左旋右旋的性质可以知道，实际改变了父子关系的节点是上图的：x、y、B节点。因为实际上，A、C节点的父子关系并没有发生任何改变。</p>
<p>并且我们能够注意到，x与y节点的连接方向一定是与x和B的连接方向不同的。</p>
<p>那么，我们只需要先通过“identify”函数确定x与y的父子关系，确定到底要向那一边旋转（如果x是y的左孩子，那么就向右旋转。如果x是y的右孩子，那么就向左旋转），然后通过逻辑异或来确定子树“B”究竟应当被连接在y的哪一侧。</p>
<pre><code>void rotate(int x)
{
    int y=e[x].father;
    int mroot=e[y].father;
    int mrootson=identify(y);
    int yson=identify(x);
    int B=e[x].ch[yson^1];
    connect(B,y,yson);connect(y,x,(yson^1));connect(x,mroot,mrootson);
    update(y);update(x);
}</code></pre><h2 id="伸展操作-splay"><a href="#伸展操作-splay" class="headerlink" title="伸展操作(splay)"></a>伸展操作(splay)</h2><p>其实就是考虑上旋节点的方式。</p>
<p>在这里，一开始我使用了一种较为偷懒的旋转方式，即能向上旋转就向上旋转。并不考虑上面的状况到底怎样。</p>
<p>其实，标准的写法中，需要考虑两种情况。如下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/4412.png" alt="12"></p>
<p>为了防止造成误导，我将不再介绍直接上旋的操作。但事实上，无论是直接上旋还是先判断再上旋，都会有可能进化或者退化原本的树形结构。</p>
<p>我也曾举出过两种操作模式各自进化或者退化树的例子。但是根据交题情况，在洛谷的模板题中，直接上旋的速度更快。然而在湖南的一道省选题中，使用直接上旋的模式却直接导致超时（大概慢了10倍）。所以说在面对大数据的不确定因素下，还是应当选择考虑更多种情况，而不能图方便。</p>
<p>在这里，我的函数实现的操作是：将at节点旋转到to节点所在的位置。</p>
<pre><code>void splay(int at,int to)
{
    to=e[to].father;
    while(e[at].father!=to)
    {
        int up=e[at].father;
        if(e[up].father==to) rotate(at);
        else if(identify(up)==identify(at))
        {//对应图中case1
            rotate(up);
            rotate(at);
        }
        else
        {//对应图中case2
            rotate(at);
            rotate(at);
        }
    }
}</code></pre><h2 id="添加节点-crepoint-和摧毁节点-destroy"><a href="#添加节点-crepoint-和摧毁节点-destroy" class="headerlink" title="添加节点(crepoint)和摧毁节点(destroy)"></a>添加节点(crepoint)和摧毁节点(destroy)</h2><p>这两个操作是在插入新元素和删除元素过程中使用的函数。</p>
<p>crepoint的作用是获得一个新的树存储位置，然后为这个存储空间写入基本的信息，并返回使用的存储位置编号。</p>
<p>destroy的作用则是使得一个节点完全失效，完全抹除节点信息，防止其他意外的发生。并且添加了一个小小的优化：如果被抹除的节点恰好是存储数组的当前最后一个元素，那么就对存储空间的使用数减1。</p>
<p>实际上，也可以通过一个队列来确定那些节点在中间被挖空了。但这样的操作不仅要牺牲一个O(log N)的时间复杂度，而且事实上并没有太大的用处，因为你开的数组大小一定能够满足极端情况（比如说所有操作都是插入）。</p>
<pre><code>int crepoint(int v,int father)
{
    n++;
    e[n].v=v;
    e[n].father=father;
    e[n].sum=e[n].recy=1;
    return n;
}
void destroy(int x) 
{
    e[x].v=e[x].ch[0]=e[x].ch[1]=e[x].sum=e[x].father=e[x].recy=0;
    if(x==n) n--;
}</code></pre><h2 id="查找元素-find"><a href="#查找元素-find" class="headerlink" title="查找元素(find)"></a>查找元素(find)</h2><p>要实现的功能是找特定值是否在树中以及对应的节点编号。</p>
<p>很简单的实现方式。从根开始向下移动，如果要找的元素比当前节点小，那么就转到自己的左孩子。否则，就转向自己的右孩子，直到节点值等于要找的值。</p>
<p>如果在找到目标值之前，需要走的路已经无法再走（比如说现在到了5，要找的是3，应该往左走，但是5已经没有左孩子了），那么则查找失败，返回失败值（0）。如果查找成功，则返回节点对应的编号。</p>
<p>查找结束后，将被查找的节点旋转到根，以保证树的结构随机性。</p>
<pre><code>int find(int v) 
{
    int now=root;
    while(true)
    {
        if(e[now].v==v)
        {
            splay(now,root);
            return now;
        }
        int next=v&lt;e[now].v?0:1;
        if(!e[now].ch[next]) return 0;
        now=e[now].ch[next];
    }
}</code></pre><p>建树(build)</p>
<p>建树的功能我并没有看懂大佬们的操作到底是什么意思。。。（我觉得应该是将Splay用作线段树的时候使用的功能）所以我写了一个没有上旋操作的insert函数。</p>
<p>首先，从根开始，向下寻找。如果要插入的元素已经在树中，那么将这个节点的recy加1即可。如果没有出现过，那么找一个合适的空的位置。找到位置后，调用crepoint函数，在数组中申请一个新的下标存储元素。</p>
<p>同时注意，在向下寻找的过程中，对被经过的点的sum值加1，因为如果经过这个点，代表要加的点肯定在自己下面，所以自己下面的元素个数加1。</p>
<pre><code>int build(int v)//内部调用的插入函数，没有splay 
{
    points++;
    if(n==0)//特判无点状态 
    {
        root=1;
        crepoint(v,0);
    }
    else
    {
        int now=root;
        while(true)//向下找到一个空节点 
        {
            e[now].sum++;//自己的下级肯定增加了一个节点 
            if(v==e[now].v)
            {
                e[now].recy++;
                return now;
            }
            int next=v&lt;e[now].v?0:1;
            if(!e[now].ch[next])
            {
                crepoint(v,now);
                e[now].ch[next]=n;
                return n;
            }
            now=e[now].ch[next];
        }
    }
    return 0;
}</code></pre><h2 id="插入节点-push"><a href="#插入节点-push" class="headerlink" title="插入节点(push)"></a>插入节点(push)</h2><p>就是在进行完build操作以后，执行一次上旋操作，确保树的结构随机性。</p>
<pre><code>void push(int v)
{
    int add=build(v);
    splay(add,root);
}</code></pre><h2 id="删除节点-pop"><a href="#删除节点-pop" class="headerlink" title="删除节点(pop)"></a>删除节点(pop)</h2><p>将输入值对应的节点在树中移除。</p>
<p>进行这样的操作时，我一开始考虑的是通过逐层的rotate操作将要被删除的节点转到最下方，然后再删除，最后逐层向上改变路径上的sum值。但是考虑到这样的操作可能会一方面导致树的大幅度退化，另一方面相当于要进行两次O(log N)的时间复杂度操作，常数略大，可能会成为一颗定时炸弹。所以为了稳定，还是用了常规的方法：</p>
<p>首先将要删除的节点旋转到根节点的位置。</p>
<p>然后，判断情况：如果要被删除的节点（注意现在它在根的位置）没有左孩子，那么直接摧毁这个节点，并将它的右孩子变成根。</p>
<p>如果自己有左孩子，那么就先把左子树中值最大的元素旋转到根的左孩子位置，然后将根节点的右孩子变成根节点的左孩子的右孩子，然后摧毁节点，并将左孩子变成根。</p>
<p>原理还请读者自己考虑吧，根据二叉排序树的性质。。。</p>
<pre><code>void pop(int v)//删除节点 
{
    int deal=find(v);
    if(!deal) return;
    points--;
    if(e[deal].recy&gt;1)
    {
        e[deal].recy--;
        e[deal].sum--;
        return;
    }
    if(!e[deal].ch[0])
    {
        root=e[deal].ch[1];
        e[root].father=0;
    }
    else
    {
        int lef=e[deal].ch[0];
        while(e[lef].ch[1]) lef=e[lef].ch[1];
        splay(lef,e[deal].ch[0]);
        int rig=e[deal].ch[1];
        connect(rig,lef,1);connect(lef,0,1);
        update(lef);
    }
    destroy(deal);
}</code></pre><h2 id="获取元素的排名（rank）-amp-获取该排名对应的元素值（atrank）"><a href="#获取元素的排名（rank）-amp-获取该排名对应的元素值（atrank）" class="headerlink" title="获取元素的排名（rank）&amp;获取该排名对应的元素值（atrank）"></a>获取元素的排名（rank）&amp;获取该排名对应的元素值（atrank）</h2><p>两个函数是互逆的函数。</p>
<p>rank的实现根find差不多，只是在向下走的时候，对于当前已经记录的rank值进行更新（每次调用rank时都初始化为0）。规则是：向左走时，rank值不发生任何改变。向右走之前，要先给rank加上当前节点的左孩子的sum值和recy值。找到对应元素时，再对rank+1。如下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/4413.png" alt="12"></p>
<p>atrank函数根rank实现完全相反。在向下走的过程中，如果要找的排名大于当前点左子树的sum值，并且小于等于当前点的左子树的sum加上本节点的recy的值，那么当前的点就是要找的点。如果小于上述范围，就往左走，反之向右。注意向右走的过程中，将要查询的排名值减少上述范围的最大值。</p>
<p>两个操作结束后，都要将被操作的节点旋转到根。</p>
<pre><code>int rank(int v)//获取值为v的元素在这棵树里是第几小 
{
    int ans=0,now=root;
    while(true)
    {
        if(e[now].v==v) return ans+e[e[now].ch[0]].sum+1;
        if(now==0) return 0;
        if(v&lt;e[now].v) now=e[now].ch[0];
        else
        {
            ans=ans+e[e[now].ch[0]].sum+e[now].recy;
            now=e[now].ch[1];
        }
    }
    if(now) splay(now,root);
    return 0;
}
int atrank(int x)//获取第x小的元素的值 
{
    if(x&gt;points) return -INF;
    int now=root;
    while(true)
    {
        int minused=e[now].sum-e[e[now].ch[1]].sum;
        if(x&gt;e[e[now].ch[0]].sum&amp;&amp;x&lt;=minused) break;
        if(x&lt;minused) now=e[now].ch[0];
        else
        {
            x=x-minused;
            now=e[now].ch[1];
        }
    }
    splay(now,root);
    return e[now].v;
}</code></pre><h2 id="查找前驱（lower）和后继（upper）"><a href="#查找前驱（lower）和后继（upper）" class="headerlink" title="查找前驱（lower）和后继（upper）"></a>查找前驱（lower）和后继（upper）</h2><p>两种操作是类似的操作。</p>
<p>前驱是指在树中，小于这个值并且最接近这个值的元素值。</p>
<p>后继则是大于这个值并且最接近这个值的元素值。</p>
<p>对于这两种函数的实现方式，就是先初始化一个最值，然后在向下走的过程中，如果发现了符合要求且更优的值，就用更优值替换当前的值。最后不能走的时候输出这个值即可。</p>
<pre><code>int upper(int v) 
{
    int now=root;
    int result=INF;
    while(now)
    {
        if(e[now].v&gt;v&amp;&amp;e[now].v&lt;result) result=e[now].v;
        if(v&lt;e[now].v) now=e[now].ch[0];
        else now=e[now].ch[1];
    }
    return result;
}
int lower(int v) 
{
    int now=root;
    int result=-INF;
    while(now)
    {
        if(e[now].v&lt;v&amp;&amp;e[now].v&gt;result) result=e[now].v;
        if(v&gt;e[now].v) now=e[now].ch[1];
        else now=e[now].ch[0];
    }
    return result;</code></pre><p>完结撒花~  恭喜你坚持了下来，至此你应该对Splay有了大致的了解，其中的思路大致如此，具体的实现会因人而异，下面我将贴上另一种Splay实现，思路都是一样的，细节实现稍有不同<br>，你可以与上面的代码作对比，并加深理解。</p>
<pre><code>#include&lt;cstdio&gt;
#define maxn 200500

int n,opt,cnt,root;
int val[maxn],son[maxn][2],fa[maxn],size[maxn],sum[maxn];

inline void destroy(int u){
    val[u] = son[u][0] = son[u][1] = fa[u] = sum[u] = size[u] = 0;
}

inline int identify(int u){
    return son[fa[u]][1] == u;
}

inline void update(int u){
    if(u)
        sum[u] = sum[son[u][0]]+sum[son[u][1]]+size[u];
}

void rotate(int u){
    int f = fa[u],gf = fa[f],sta = identify(u),sta_f = identify(f);
    son[f][sta] = son[u][sta^1];
    fa[son[f][sta]] = f;
    son[u][sta^1] = f,fa[f] = u,fa[u] = gf;
    son[gf][sta_f] = u;
    update(f),update(u);
}

void splay(int u){
    for(int f;f = fa[u];rotate(u))
        if(fa[f])
            rotate(identify(u)==identify(f) ? f:u);
    root = u;
}

void insert(int u){
    if(!root){
        val[++cnt] = u;
        size[cnt] = sum[cnt] = 1;
        root = cnt;
        return ;
    }
    int now = root,f = 0;
    while(true){
        if(u == val[now]){
            ++size[now];
            update(now),update(f);
            splay(now);
            return ;
        }
        f = now,now = son[now][val[now]&lt;u];
        if(!now){
            val[++cnt] = u;
            size[cnt] = sum[cnt] = 1;
            fa[cnt] = f,son[f][val[f]&lt;u] = cnt;
            ++sum[f];
            splay(cnt);
               return ;
        }
    }
}

int find_num(int u){
    int now = root;
    while(true){
        if(son[now][0]&amp;&amp;u &lt;= sum[son[now][0]])
            now = son[now][0];
        else{
            int temp = sum[son[now][0]]+size[now];
            if(u &lt;= temp)
                return val[now];
            now = son[now][1],u -= temp;
        }
    }
}

int find_rank(int u){
    int now = root,rank = 0;
    while(true){
        if(u &lt; val[now])
            now = son[now][0];
        else{
            rank += sum[son[now][0]];
            if(u == val[now]){
                splay(now);
                return rank+1;
            }
            rank += size[now],now = son[now][1];
        }
    }
}

int find_pre(){     //注意这里查找前驱后继的函数和上面不一样，实现思路见下面主函数里的注释    
    int now = son[root][0];
    while(son[now][1])
        now = son[now][1];
    return now;
}

int find_suffix(){
    int now = son[root][1];
    while(son[now][0])
        now = son[now][0];
        return now;
}

void delete_val(int u){        //按照二叉搜索树(BST)的思路删点
    find_rank(u);
    if(size[root] &gt; 1){
        --size[root],--sum[root];
        return ;
    }
    if(!son[root][0] &amp;&amp; !son[root][1]){
        destroy(root),root = 0;
        return ;
    }
    int old_root = root;
    if(!son[root][0]){
        root = son[root][1];
        fa[root] = 0;
        destroy(old_root);
        return ;
    }
    if(!son[root][1]){
        root = son[root][0];    
        fa[root] = 0;
        destroy(old_root);
        return ;
    }
    int left_max = find_pre();
    splay(left_max);
    son[root][1] = son[old_root][1];
    fa[son[old_root][1]] = root;
    destroy(old_root);
    update(root);
}    

int main(){
    int x;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--){
        scanf(&quot;%d%d&quot;,&amp;opt,&amp;x);
        if(opt == 1)
            insert(x);
        else if(opt == 2)
            delete_val(x);
        else if(opt == 3)
            printf(&quot;%d\n&quot;,find_rank(x));
        else if(opt == 4)
            printf(&quot;%d\n&quot;,find_num(x));
        else if(opt == 5){  //与上面不同，5和6操作是先插入要删除的值，目的是将储存该值的节点上旋到跟节点，这样左子树的最大值就是答案。
            insert(x);
            printf(&quot;%d\n&quot;,val[find_pre()]);
            delete_val(x);
        }
        else{
            insert(x);
            printf(&quot;%d\n&quot;,val[find_suffix()]);
            delete_val(x);
        }
    }
    return 0;
}</code></pre><p>最后再奉上一道练习题，这道题也可以当做线段树合并的入门题。</p>
<p><a href="https://www.luogu.com.cn/problem/P3224" target="_blank" rel="noopener">洛谷p3224永无乡</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/%E4%B8%BB%E5%B8%AD%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/%E4%B8%BB%E5%B8%AD%E6%A0%91/" class="post-title-link" itemprop="url">主席树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-05 16:54:33" itemprop="dateCreated datePublished" datetime="2020-04-05T16:54:33+08:00">2020-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-17 10:29:37" itemprop="dateModified" datetime="2020-04-17T10:29:37+08:00">2020-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">线段树</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="可持久化线段树（主席树）"><a href="#可持久化线段树（主席树）" class="headerlink" title="可持久化线段树（主席树）"></a>可持久化线段树（主席树）</h1><h2 id="前置芝士-：-线段树，离散化（部分题目需要）"><a href="#前置芝士-：-线段树，离散化（部分题目需要）" class="headerlink" title="前置芝士   ：  线段树，离散化（部分题目需要）"></a>前置芝士   ：  线段树，离散化（部分题目需要）</h2><blockquote>
<p><a href="https://www.cnblogs.com/TenosDoIt/p/3453089.html" target="_blank" rel="noopener">如果还不了解线段树可以戳这里</a></p>
</blockquote>
<p>主席树是一种以线段树为基础的可以快速查询区间第k小（大）的数据结构，其中可持久化的意思就是对于每次修改，我们都将结果保存下来，然后你可以随时查询修改之前任意一次操作时所对应的线段树，类似于git，可以查看历史版本。为了实现这一功能，容易想到的是暴力建树，即对于每次操作都重新建立一颗线段树，但这样做时间空间肯定会炸的稀里哗啦。于是我们换个角度想，考虑到对于每次修改，实际变动的节点只是少数，如下图：<br><img src="../image/20234.png" alt="233"></p>
<p>假如现在正在进行第x次操作，我们对原序列第四个点进行修改，其中橙色节点是第x-1次操作对应的线段树的节点，而其右边是第x次操作新建立的线段树节点。这里若修改第4个点，则只有橙色的节点维护的信息发生了变动，而其他节点都保持不变，考虑到这一特点，在每次修改后，我们只需要创建与受到影响的节点（橙色节点）相对应的节点（橙色节点右边的节点），然后让他们共用那些没有被影响的节点，这样一来，便可以很快的建好第x次操作所对应的线段树，并且极大节约了空间。（与普通线段树不同的是，节点的左右儿子编号并不能被计算出来，需要另行记录）</p>
<p>下面我们通过一道例题具体实现下，此题需进行离散化 <a href="https://www.cnblogs.com/lornd/p/11167316.html" target="_blank" rel="noopener">可参考这篇博客的方法二</a></p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">例题 洛谷p3834</a></p>
</blockquote>
<p>题意<br>给定 n 个整数构成的序列，将对于指定的闭区间查询其区间内的第 k 小值。</p>
<p>输入格式<br>第一行包含两个正整数 n,mn,m，分别表示序列的长度和查询的个数。</p>
<p>第二行包含 nn 个整数，表示这个序列各项的数字。</p>
<p>接下来 mm 行每行包含三个整数 l, r, kl,r,k , 表示查询区间 [l, r][l,r] 内的第 kk 小值。</p>
<p>输出格式<br>输出包含 mm 行，每行一个整数，依次表示每一次查询的结果</p>
<p>数据范围<br>1 &lt;= n,m &lt;= 2*10^5  数列中的所有数绝对值都不超过10^9</p>
<p>这是一道板子题，我将结合代码用注释解释</p>
<p><strong>Code</strong></p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define maxn 200005
using std::sort;
using std::unique;
using std::lower_bound;

int n,m,cnt,p,k,l,r;
int cl[maxn&lt;&lt;5],cr[maxn&lt;&lt;5],sum[maxn&lt;&lt;5];
//cl[i],cr[i],sun[i]分别为i号节点的左孩子序号,右孩子序号,i号节点管理的区间和
int rt[maxn],a[maxn],b[maxn];
//rt[i]是第i颗线段树的根节点号码，a,b分别是原数组和其副本
int change(int u,int l,int r){    //u是与现在访问的节点相对应的上一颗数的节点号码，l,r是该号码所管理的区间
    int t = ++cnt;    //t是新建立的节点号码
    cl[t] = cl[u],cr[t] = cr[u],sum[t] = sum[u]+1; //先让t号节点继承上一颗线段树与之对应的节点的信息
    if(l == r)        //该节点没有孩子了，结束更新
        return t;
    int mid = (l+r)&gt;&gt;1;
    if(p &lt;= mid)    //变动的节点在左子树，递归进入左子树创立新节点
        cl[t] = change(cl[u],l,mid);
    else
        cr[t] = change(cr[u],mid+1,r);
    return t;    //返回这次创立的节点序号
}

int query(int fu,int u,int l,int r,int k){    //返回第k小的数离散化后的rank
    if(l == r)
        return l;
    int mid = (l+r)&gt;&gt;1,num = sum[cl[u]]-sum[cl[fu]];    //主席树是可减的，这里实际模拟下就很清楚了
    if(num &gt;= k)
        return query(cl[fu],cl[u],l,mid,k);
    else
        return query(cr[fu],cr[u],mid+1,r,k-num);
}

int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i = 1;i &lt;= n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
        b[i] = a[i];    //因为要进行离散化，而之后还要用该数组的值，所以创建副本
    }
    //   下面是离散化操作
    sort(b+1,b+1+n);
    int len = unique(b+1,b+1+n)-b-1;
    for(int i = 1;i &lt;= n;i++){        //对原数组下标1-i的数建一颗线段树（也就是一个版本），一共会建立n颗线段树
        p = lower_bound(b+1,b+1+len,a[i])-b;
        rt[i] = change(rt[i-1],1,len);    //change函数会创建新节点，同时返回新创建的节点标号
    }
    while(m--){
        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);
        int t = query(rt[l-1],rt[r],1,len,k);
        printf(&quot;%d\n&quot;,b[t]);
    }
    return 0;
}</code></pre><p>下面放两道主席树的其他类型题目<br>洛谷 p3919<br>洛谷 p3402</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/%E7%BD%91%E7%BB%9C%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/%E7%BD%91%E7%BB%9C%E6%B5%81/" class="post-title-link" itemprop="url">网络流</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 15:53:38" itemprop="dateCreated datePublished" datetime="2020-03-21T15:53:38+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-26 09:47:40" itemprop="dateModified" datetime="2020-03-26T09:47:40+08:00">2020-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><em>以网络流24题为例</em></strong></p>
<blockquote>
<p>匹配</p>
<blockquote>
<p>二分图匹配<br>    1.匈牙利算法<br>一般图最大匹配<br>    1.带花树算法</p>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/%E6%89%AB%E6%8F%8F%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/%E6%89%AB%E6%8F%8F%E7%BA%BF/" class="post-title-link" itemprop="url">扫描线</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 15:47:54" itemprop="dateCreated datePublished" datetime="2020-03-21T15:47:54+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-26 09:46:55" itemprop="dateModified" datetime="2020-03-26T09:46:55+08:00">2020-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前置知识：线段树-离散化"><a href="#前置知识：线段树-离散化" class="headerlink" title="前置知识：线段树  离散化"></a><strong>前置知识：线段树  离散化</strong></h2><blockquote>
<p>123</p>
<blockquote>
<p>456</p>
<ol>
<li>456</li>
<li>789</li>
</ol>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/Hello-World/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_Nice">
      <meta itemprop="description" content="你只有十分努力，才能看上去毫不费力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_Niceの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/Hello-World/" class="post-title-link" itemprop="url">Hello World</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 15:22:32" itemprop="dateCreated datePublished" datetime="2020-03-20T15:22:32+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-21 16:40:33" itemprop="dateModified" datetime="2020-03-21T16:40:33+08:00">2020-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><em>hello people</em></strong></p>
<blockquote>
<ul>
<li>欢迎光临*<blockquote>
<ul>
<li>123</li>
<li>456</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_Nice</p>
  <div class="site-description" itemprop="description">你只有十分努力，才能看上去毫不费力</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_Nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
